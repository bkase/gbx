<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>GBX UI Demo</title>
<style>
  body {
    margin: 0;
    padding: 20px;
    background: #222;
    color: #fff;
    font-family: monospace;
  }
  .canvas-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    max-width: calc(4 * 160px + 3 * 12px);
  }
  .lane-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
  }
  .lane-canvas {
    width: 160px;
    height: 144px;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    border: 2px solid #444;
    background: #111;
  }
  .lane-label {
    font-size: 12px;
    color: #aaa;
  }
  #info {
    margin-top: 10px;
    font-size: 14px;
  }
  .pass { color: #0f0; }
  .fail { color: #f00; }
</style>
</head>
<body>
  <h1 id="title">GBX UI Demo</h1>
  <div id="canvas-grid" class="canvas-grid"></div>
  <div id="info">Initializing...</div>

  <script type="module">
    import init, { gbx_consume_frame, gbx_init, gbx_load_rom, gbx_tick, gbx_debug_state } from "./pkg/fabric_worker_wasm.js";
    window.__gbxExports = { gbx_consume_frame, gbx_init, gbx_load_rom, gbx_tick, gbx_debug_state };

    const LANES = 8;
    const grid = document.getElementById("canvas-grid");
    const laneCanvases = [];
    const laneContexts = [];
    const laneFrameCounts = new Array(LANES).fill(0);
    const info = document.getElementById("info");
    const title = document.getElementById("title");

    // Check if we're in test mode
    const params = new URLSearchParams(window.location.search);
    const isTest = params.has('test');

    if (isTest) {
      title.textContent = "GBX UI Integration Test";
    }

    const romParam = params.get("rom") || "tetris.gb";
    const ROM_PATH = `./roms/${romParam}`;
    const romLabel = romParam.replace(/\.[^.]+$/, "");

    function setInfo(msg) {
      if (isTest) {
        info.innerHTML += `<div>${msg}</div>`;
      } else {
        info.textContent = msg;
      }
    }

    function log(msg) {
      console.log(msg);
      setInfo(msg);
    }

    function pass(msg) {
      console.log(`WASM_TEST_PASS: ${msg}`);
      if (isTest) {
        log(`<span class="pass">✓ ${msg}</span>`);
      }
    }

    function fail(msg) {
      console.error(`WASM_TEST_FAIL: ${msg}`);
      if (isTest) {
        log(`<span class="fail">✗ ${msg}</span>`);
      }
      throw new Error(msg);
    }

    function setupCanvasGrid() {
      if (laneCanvases.length === LANES) {
        return;
      }
      for (let lane = 0; lane < LANES; lane++) {
        const wrapper = document.createElement("div");
        wrapper.className = "lane-wrapper";

        const canvas = document.createElement("canvas");
        canvas.className = "lane-canvas";
        canvas.width = 160;
        canvas.height = 144;
        canvas.dataset.lane = String(lane);

        const label = document.createElement("div");
        label.className = "lane-label";
        label.textContent = `Lane ${lane}`;

        wrapper.appendChild(canvas);
        wrapper.appendChild(label);
        grid.appendChild(wrapper);

        laneCanvases[lane] = canvas;
        laneContexts[lane] = canvas.getContext("2d");
      }
    }

    setupCanvasGrid();

    function ensureCanvasSize(canvas, width, height) {
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    function drawFrame(lane, width, height, pixels) {
      const canvas = laneCanvases[lane];
      const context = laneContexts[lane];
      if (!canvas || !context || !pixels) {
        return false;
      }
      ensureCanvasSize(canvas, width, height);
      const data = pixels instanceof Uint8ClampedArray ? pixels : new Uint8ClampedArray(pixels);
      const image = new ImageData(data, width, height);
      context.putImageData(image, 0, 0);
      laneFrameCounts[lane] = (laneFrameCounts[lane] || 0) + 1;
      const label = canvas.nextElementSibling;
      if (label) {
        label.textContent = `Lane ${lane} (${laneFrameCounts[lane]})`;
      }
      return true;
    }

    function consumeLaneFrame(report) {
      const lane = Number.isFinite(report.lane)
        ? Math.max(0, Math.min(LANES - 1, Number(report.lane)))
        : 0;
      let width = report.width || 160;
      let height = report.height || 144;
      let pixels = null;

      if (report.pixels) {
        pixels = report.pixels;
      } else if (typeof report.start_idx === "number") {
        const slotCount = typeof report.slot_count === "number" ? report.slot_count : 1;
        const frame = gbx_consume_frame(report.start_idx, slotCount, width, height);
        width = frame.width || width;
        height = frame.height || height;
        pixels = frame.pixels;
        if (window.__gbxDebug !== false) {
          const sample = pixels instanceof Uint8ClampedArray ? pixels.slice(0, 16) : Array.from(pixels.slice(0, 16));
          console.log(`consumeLaneFrame lane=${lane} frame_id=${report.frame_id} slot_idx=${report.start_idx} slot_count=${slotCount} sample=${sample}`);
        }
      }

      if (pixels) {
        return drawFrame(lane, width, height, pixels);
      }

      return false;
    }

    async function fetchRomBytes() {
      const response = await fetch(ROM_PATH);
      if (!response.ok) {
        throw new Error(`ROM fetch failed: ${response.status} ${response.statusText}`);
      }
      return new Uint8Array(await response.arrayBuffer());
    }

    async function runTest() {
      try {
        pass("WASM module loaded");

        log("Calling gbx_init()...");
        gbx_init();
        pass("gbx_init() succeeded");

        log(`Loading ROM: ${romLabel} (${ROM_PATH})...`);
        const rom = await fetchRomBytes();
        gbx_load_rom(rom);
        pass("gbx_load_rom() succeeded");

        let foundLaneFrame = false;
        for (let i = 0; i < 16 && !foundLaneFrame; i++) {
          const reports = gbx_tick(32);
          log(`Tick ${i}: ${reports.length} reports`);
          for (const r of reports) {
            log(`  Report type: ${r.type}`);
            if (r.type === "Kernel.LaneFrame") {
              if (consumeLaneFrame(r)) {
                pass(`LaneFrame ready (frame_id=${r.frame_id}, lane=${r.lane})`);
                foundLaneFrame = true;
                break;
              }
            }
          }
        }

        if (!foundLaneFrame) {
          fail("No LaneFrame observed within tick budget");
        }

        pass("All UI export smoke tests passed");
        console.log("WASM_TEST_DONE");
      } catch (e) {
        fail(`Test failed: ${e.message}`);
      }
    }

    async function runDemo() {
      try {
        gbx_init();
      } catch (e) {
        info.textContent = `Init error: ${e}`;
        throw e;
      }

      try {
        const rom = await fetchRomBytes();
        gbx_load_rom(rom);
        info.textContent = `ROM loaded (${romLabel}). Running...`;
      } catch (e) {
        info.textContent = `ROM load failed: ${e.message}`;
        throw e;
      }

      let totalFrames = 0;
      let startTime = Date.now();

      function loop() {
        try {
          const reports = gbx_tick(64);
          for (const report of reports) {
            if (report.type === "Kernel.LaneFrame" && consumeLaneFrame(report)) {
              totalFrames++;
            }
          }

          if (totalFrames > 0 && totalFrames % 60 === 0) {
            const elapsed = (Date.now() - startTime) / 1000;
            const fps = (totalFrames / Math.max(elapsed, 0.001)).toFixed(1);
            const laneSummary = laneFrameCounts
              .map((count, lane) => `L${lane}:${count}`)
              .join(" ");
            info.textContent = `Frames: ${totalFrames} | FPS: ${fps} | ${laneSummary}`;
          }
        } catch (e) {
          info.textContent = `Runtime error: ${e}`;
          console.error(e);
          return;
        }

        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    }

    await init();

    if (isTest) {
      await runTest();
    } else {
      await runDemo();
    }
  </script>
</body>
</html>
