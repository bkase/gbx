<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>GBX UI Demo</title>
<style>
  body {
    margin: 0;
    padding: 20px;
    background: #222;
    color: #fff;
    font-family: monospace;
  }
  #c {
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    border: 2px solid #444;
  }
  #info {
    margin-top: 10px;
    font-size: 14px;
  }
  .pass { color: #0f0; }
  .fail { color: #f00; }
</style>
</head>
<body>
  <h1 id="title">GBX UI Demo</h1>
  <canvas id="c" width="160" height="144"></canvas>
  <div id="info">Initializing...</div>

  <script type="module">
    import init, { gbx_consume_frame, gbx_init, gbx_load_rom, gbx_tick } from "./pkg/fabric_worker_wasm.js";

    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const info = document.getElementById("info");
    const title = document.getElementById("title");

    // Check if we're in test mode
    const params = new URLSearchParams(window.location.search);
    const isTest = params.has('test');

    if (isTest) {
      title.textContent = "GBX UI Integration Test";
    }

    const ROM_PATH = "./roms/tetris.gb";

    function setInfo(msg) {
      if (isTest) {
        info.innerHTML += `<div>${msg}</div>`;
      } else {
        info.textContent = msg;
      }
    }

    function log(msg) {
      console.log(msg);
      setInfo(msg);
    }

    function pass(msg) {
      console.log(`WASM_TEST_PASS: ${msg}`);
      if (isTest) {
        log(`<span class="pass">✓ ${msg}</span>`);
      }
    }

    function fail(msg) {
      console.error(`WASM_TEST_FAIL: ${msg}`);
      if (isTest) {
        log(`<span class="fail">✗ ${msg}</span>`);
      }
      throw new Error(msg);
    }

    function ensureCanvasSize(width, height) {
      if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
      }
    }

    function drawFrame(width, height, pixels) {
      if (!pixels) {
        return;
      }
      ensureCanvasSize(width, height);
      const data = pixels instanceof Uint8ClampedArray ? pixels : new Uint8ClampedArray(pixels);
      const image = new ImageData(data, width, height);
      ctx.putImageData(image, 0, 0);
    }

    function consumeLaneFrame(report) {
      let width = report.width || 160;
      let height = report.height || 144;
      let pixels = null;

      if (report.pixels) {
        pixels = report.pixels;
      } else if (typeof report.start_idx === "number") {
        const slotCount = typeof report.slot_count === "number" ? report.slot_count : 1;
        const frame = gbx_consume_frame(report.start_idx, slotCount, width, height);
        width = frame.width || width;
        height = frame.height || height;
        pixels = frame.pixels;
      }

      if (pixels) {
        drawFrame(width, height, pixels);
      }

      return Boolean(pixels);
    }

    async function fetchRomBytes() {
      const response = await fetch(ROM_PATH);
      if (!response.ok) {
        throw new Error(`ROM fetch failed: ${response.status} ${response.statusText}`);
      }
      return new Uint8Array(await response.arrayBuffer());
    }

    async function runTest() {
      try {
        pass("WASM module loaded");

        log("Calling gbx_init()...");
        gbx_init();
        pass("gbx_init() succeeded");

        log("Loading blargg 03 ROM...");
        const rom = await fetchRomBytes();
        gbx_load_rom(rom);
        pass("gbx_load_rom() succeeded");

        let foundLaneFrame = false;
        for (let i = 0; i < 16 && !foundLaneFrame; i++) {
          const reports = gbx_tick(32);
          log(`Tick ${i}: ${reports.length} reports`);
          for (const r of reports) {
            log(`  Report type: ${r.type}`);
            if (r.type === "Kernel.LaneFrame") {
              if (consumeLaneFrame(r)) {
                pass(`LaneFrame ready (frame_id=${r.frame_id}, lane=${r.lane})`);
                foundLaneFrame = true;
                break;
              }
            }
          }
        }

        if (!foundLaneFrame) {
          fail("No LaneFrame observed within tick budget");
        }

        pass("All UI export smoke tests passed");
        console.log("WASM_TEST_DONE");
      } catch (e) {
        fail(`Test failed: ${e.message}`);
      }
    }

    async function runDemo() {
      try {
        gbx_init();
      } catch (e) {
        info.textContent = `Init error: ${e}`;
        throw e;
      }

      try {
        const rom = await fetchRomBytes();
        gbx_load_rom(rom);
        info.textContent = "ROM loaded. Running...";
      } catch (e) {
        info.textContent = `ROM load failed: ${e.message}`;
        throw e;
      }

      let frameCount = 0;
      let startTime = Date.now();

      function loop() {
        try {
          const reports = gbx_tick(64);
          for (const report of reports) {
            if (report.type === "Kernel.LaneFrame" && consumeLaneFrame(report)) {
              frameCount++;
            }
          }

          if (frameCount > 0 && frameCount % 60 === 0) {
            const elapsed = (Date.now() - startTime) / 1000;
            const fps = (frameCount / Math.max(elapsed, 0.001)).toFixed(1);
            info.textContent = `Frames: ${frameCount} | FPS: ${fps}`;
          }
        } catch (e) {
          info.textContent = `Runtime error: ${e}`;
          console.error(e);
          return;
        }

        requestAnimationFrame(loop);
      }

      requestAnimationFrame(loop);
    }

    await init();

    if (isTest) {
      await runTest();
    } else {
      await runDemo();
    }
  </script>
</body>
</html>
